package com.company.chapter07reusingclasses.examples.e09sokritieImen;
// Перегрузка имени метода из базового класса
// в производном классе не скроет базовую версию метода.

/**
 * Если какой-либо из методов базового KnaccaJava был перегружен несколько раз, переопределение имени этого метода в производном классе не скроет ни одну из базовых
 * версий (в отличие от С++). Поэтому перегрузка работает вне зависимости от того, где
 * был определен метод — на текущем уровне или в базовом классе
 * <p>
 * Мы видим, что все перегруженные методы класса Homer доступны классу Bart, хотя
 * класс Bart и добавляет новый перегруженный метод Как вы увидите в следующей главе, на практике при
 * переопределении методов гораздо чаще используется точно такое же описание и список
 * аргументов, как и в базовом классе.
 */
class Scratch_2 {
    public static void main(String[] args) {
        Bart b = new Bart();
        b.doh('x');//метод родительского класса Гомер, унаследован
        b.doh(1); //метод родительского класса Гомер, унаследован
        b.doh(1.0f);//метод родительского класса Гомер, унаследован
        b.doh(new Milhouse());//метод класса Барт

    }
}