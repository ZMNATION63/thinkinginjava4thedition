package com.company.chapter10innerclasses.examples.example014multiInterafaces.multiimplementationp2;

/**
 * если вместо интерфейсов у вас имеются конкретные или абстрактные классы,
 * придется «звать на помощь» внутренние классы, если новый класс должен как-то
 * задействовать функциональность двух других классов
 */

class De {

}

abstract class E {
}

class Z extends De {
    E makeE() {
        return new E() {
        };
    }
}

class Multiimplementation {
    static void takesD(De d) {
    }

    static void takesE(E e) {
    }

    public static void main(String[] args) {
        Z z = new Z();
        takesD(z);
        takesE(z.makeE());
    }
}

/**
 * 1. У внутреннего класса может существовать произвольное количество экземпляров,
 * каждый из которых содержит собственную информацию, не зависящую от состояния объекта внешнего класса.
 * 2. Один внешний класс может содержать несколько внутренних классов, которые
 * по-разному реализуют один интерфейс или наследуют от единственного базового
 * класса. Пример такой конструкции вскоре будет рассмотрен.
 * 3. Место создания объекта внутреннего класса не привязано к месту и времени создания объекта внешнего класса.
 * 4. Внутренний класс не создает взаимосвязи классов типа «является тем-то», способной вызвать путаницу; он представляет собой отдельную сущность.
 */