package com.company.chapter08polymorphism.examples.e03poluchenienujnogorezultata;

/**
 * Базовый класс S h a p e устанавливает общий интерфейс для всех классов, производных
 * от S h a p e , — то естьлюбую фигуру можно нарисовать ( d r a w ( ) ) n стереть ( e r a s e ( ) ) .
 * Производные классы переопределяют этот интерфейс, чтобы реализовать уникальное
 * поведение для каждой конкретной фигуры.
 * Класс R a n d o m S h a p e G e n e ra to r — своего рода «фабрика», при каждом вызове метода n e x t ( )
 * производящая ссылку на случайно выбираемый объект Sh ape. Заметьте, что восходящее
 * преобразование выполняется в командах r e t u r n , каждая из которых получает ссылку
 * на объект C i r c l e , S q u a r e или T r i a n g l e , а выдает ее за пределы n e x t ( )
 * в виде возвращаемого типа S h a p e . Таким образом, при вызове этого метода вы не сможете определить
 * конкретный тип объекта, поскольку всегда получаете просто S h a p
 * <p>
 * 2. (1)Добавьте аннотацию @Overrid e в пример с фигурами. DONE
 * <p>
 * 3. (1) Включите в базовый класс Shapes.java новый метод, выводящий сообщение, но
 * не переопределяйте его в производных классах. Объясните результат.
 * Переопределите его в одном из производных классов и посмотрите, что происходит.
 * Наконец, переопределите метод во всех производных классах.
 * <p>
 * 4. (2) Добавьте новый подтип Shape к программе Shapes.java и проверьте на методе
 * main( ) , что полиморфизм работает правильно для вашего нового типа, так же как
 * и для старых типов.
 * <p>
 */
class Scratch_1 {
    private static RandomShapeGenerator gen = new RandomShapeGenerator();

    public static void main(String[] args) {

        Shape[] s = new Shape[10];
//Заполняеммассивфигурами:
        for (int i = 0; i < s.length; i++)
            s[i] = gen.next();
//Полиморфныевызовыметодов:
        for (Shape shp : s) {
            shp.draw();
            shp.methodNew();
        }
    }
}